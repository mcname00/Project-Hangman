import tkinter as tk
from tkinter import simpledialog, messagebox
import random
import os

LEADERBOARD_FILE = "leaderboard.txt"
LEADERBOARD_FILE_BLITZ = "leaderboard_blitz.txt"
LEADERBOARD_FILE_ONELIFE = "leaderboard_onelife.txt"

# The pictures that are shown throughout the game
HANGMANPICTURES = [
    """
     +----+
     |    |
     |    
     |    
     |    
     |    
    ====""",
    """
     +----+
     |    |
     |    O
     |    
     |    
     |    
    ====""",
    """
     +----+
     |    |
     |    O
     |    |
     |    
     |    
    ====""",
    """
     +----+
     |    |
     |    O
     |   /|
     |    
     |    
    ====""",
    """
     +----+
     |    |
     |    O
     |   /|\\
     |    
     |    
    ====""",
    """
     +----+
     |    |
     |    O
     |   /|\\
     |   / 
     |    
    ====""",
    """
     +----+
     |    |
     |    O
     |   /|\\
     |   / \\
     |    
    ===="""]

def load_words(filename):
    with open(filename, "r") as f:
        return [line.strip() for line in f if line.strip()]

word_list = load_words(r"C:\Users\uaa_coenglab209login\Downloads\text-based-coding-main\text-based-coding-main\words.txt")

# Hangman Start Screen
class StartScreen:
    def __init__(self, master, start_callback):
        self.master = master
        self.master.title("Hangman Start Menu")
        self.frame = tk.Frame(master, bg="#f0f0f0")
        self.frame.pack(fill="both", expand=True)

        self.title = tk.Label(
            self.frame,
            text="Welcome to Hangman!",
            font=("Arial", 32, "bold"),
            bg="#f0f0f0"
        )
        self.title.pack(pady=(40, 10))

        self.subtitle = tk.Label(
            self.frame,
            text="Guess the word before the hangman is complete!",
            font=("Arial", 14),
            fg="#555",
            bg="#f0f0f0"
        )
        self.subtitle.pack(pady=(0, 30))

        # Main gamemode buttons
        self.play_button = tk.Button(
            self.frame,
            text="Play",
            font=("Arial", 18, "bold"),
            bg="#4CAF50",
            fg="white",
            activebackground="#388E3C",
            activeforeground="white",
            width=18,
            command=lambda: self.start_game("main")
        )
        self.play_button.pack(pady=(0, 30))
        
        self.button_frame = tk.Frame(self.frame, bg="#f0f0f0")
        self.button_frame.pack(pady=(0, 30))

        self.one_life_button = tk.Button(
            self.button_frame,
            text="1 Life Mode",
            font=("Arial", 16, "bold"),
            bg="#e53935",
            fg="white",
            activebackground="#b71c1c",
            activeforeground="white",
            width=16,
            command=lambda: self.start_game("one_life")
        )
        self.one_life_button.pack(side="left", padx=10)

        self.blitz_button = tk.Button(
            self.button_frame,
            text="Blitz Mode",
            font=("Arial", 16, "bold"),
            bg="#1976d2",
            fg="white",
            activebackground="#0d47a1",
            activeforeground="white",
            width=16,
            command=lambda: self.start_game("blitz")
        )
        self.blitz_button.pack(side="left", padx=10)

        # Small challenge button in the bottom right corner
        self.challenge_button = tk.Button(
            self.master,
            text="I Want A Little Challenge",
            font=("Arial", 8, "italic"),
            bg="#fffde7",
            fg="#333",
            activebackground="#ffe082",
            activeforeground="#333",
            command=lambda: self.start_game("challenge")
        )
        self.challenge_button.place(relx=1.0, rely=1.0, anchor="se", x=-10, y=-10)

        # Leaderboard section (below the buttons)
        self.leaderboard_frame = tk.Frame(self.frame, bd=2, relief="groove", padx=16, pady=12, bg="#fffbe7")
        self.leaderboard_frame.pack(pady=(0, 30))

        leaderboard_title = tk.Label(
            self.leaderboard_frame,
            text="üèÜ Main Leaderboard üèÜ",
            font=("Arial", 14, "bold"),
            bg="#fffbe7"
        )
        leaderboard_title.pack()
        leaderboard_text = self.get_leaderboard_text(LEADERBOARD_FILE)
        self.leaderboard_label = tk.Label(
            self.leaderboard_frame,
            text=leaderboard_text,
            font=("Consolas", 11),
            justify="left",
            bg="#fffbe7"
        )
        self.leaderboard_label.pack()

        blitz_title = tk.Label(
            self.leaderboard_frame,
            text="‚ö° Blitz Leaderboard ‚ö°",
            font=("Arial", 14, "bold"),
            bg="#fffbe7"
        )
        blitz_title.pack(pady=(10, 0))
        blitz_text = self.get_leaderboard_text(LEADERBOARD_FILE_BLITZ)
        self.blitz_label = tk.Label(
            self.leaderboard_frame,
            text=blitz_text,
            font=("Consolas", 11),
            justify="left",
            bg="#fffbe7"
        )
        self.blitz_label.pack()

        onelife_title = tk.Label(
            self.leaderboard_frame,
            text="üíÄ 1 Life Leaderboard üíÄ",
            font=("Arial", 14, "bold"),
            bg="#fffbe7"
        )
        onelife_title.pack(pady=(10, 0))
        onelife_text = self.get_leaderboard_text(LEADERBOARD_FILE_ONELIFE)
        self.onelife_label = tk.Label(
            self.leaderboard_frame,
            text=onelife_text,
            font=("Consolas", 11),
            justify="left",
            bg="#fffbe7"
        )
        self.onelife_label.pack()

        self.start_callback = start_callback

    def get_leaderboard_text(self, filename):
        if not os.path.exists(filename):
            return "No scores yet!"
        with open(filename, "r") as f:
            scores = [line.strip().split(":") for line in f if ":" in line]
            scores = sorted(scores, key=lambda x: int(x[1]), reverse=True)[:10]
            if not scores:
                return "No scores yet!"
            places = ["1st", "2nd", "3rd"] + [f"{i}th" for i in range(4, 11)]
            lines = []
            for idx, (name, score) in enumerate(scores):
                place = places[idx] if idx < len(places) else f"{idx+1}th"
                lines.append(f"{place:>4}: {name:<12} {score:>5}")
            return "\n".join(lines)

    def start_game(self, mode):
        self.frame.destroy()
        self.challenge_button.destroy()
        if mode == "blitz":
            BlitzMode(self.master, lambda: StartScreen(self.master, self.start_callback))
        else:
            self.start_callback(mode)

class HangmanGUI:
    def __init__(self, master):
        self.master = master
        master.title("Hangman Game")
        self.master.bind("<F1>", self.reveal_answer)
        self.points = 0
        self.points_label = tk.Label(master, text="Points: " + str(self.points), font=("Arial", 10))
        self.points_label.pack()
        self.player_name = simpledialog.askstring("Player Name", "Enter your name:", parent=master)
        if not self.player_name:
            self.player_name = "Player"
    
        # Selects a random word based off of the word list
        self.chosen_word = list(random.choice(word_list))
        self.blank_list = ["_"] * len(self.chosen_word)
        self.update_display = 0
        self.guessed_letters = set()

        # Timer 
        self.seconds = 0
        self.timer_running = True 
        self.timer_label = tk.Label(master, text="Time: 0s", font=("Arial", 10))
        self.timer_label.place(relx=1.0, y=0, anchor="ne")
        self.update_timer()
        
        # The Font and size of the text
        self.label = tk.Label(master, text=" ".join(self.blank_list), font=("Arial", 24))
        self.label.pack()

        # The Box to put in your answers
        self.entry = tk.Entry(master)
        self.entry.pack()

        # The button used to make a guess
        self.guess_button = tk.Button(master, text="Guess", command=self.make_guess)
        self.guess_button.pack()

        # How the hangman picture is shown
        self.hangman_label = tk.Label(master, text=HANGMANPICTURES[self.update_display], font=("Courier", 16), justify="left")
        self.hangman_label.pack()
        self.entry.bind("<Return>", lambda event: self.make_guess())  

        # How the guessed letters are shown
        self.letter_bank_label = tk.Label(master, text="Guessed Letters: ")
        self.letter_bank_label.pack()

        # Shows the letters that have been guessed or win/lose/error messages
        self.message = tk.Label(master, text="")
        self.message.pack()

        # Frame for Play Again, Back to Menu, and Leaderboard buttons
        self.button_frame = tk.Frame(master)
        self.button_frame.pack(pady=10)

        self.reset_button = tk.Button(self.button_frame, text="Play Again", command=self.reset_game)
        self.reset_button.pack(side="left", padx=5)

        self.menu_button = tk.Button(self.button_frame, text="Back to Menu", command=self.back_to_menu)
        self.menu_button.pack(side="left", padx=5)

    def back_to_menu(self):
        for widget in self.master.winfo_children():
            widget.destroy()
        StartScreen(self.master, lambda: HangmanGUI(self.master))
        self.wrong_guesses = 0
        self.round_points = 0

    def reveal_answer(self, event=None):
        if not hasattr(self, "answer_label"):
            self.answer_label = tk.Label(self.master, text="Answer: " + "".join(self.chosen_word), font=("Arial", 10), fg="red")
            self.answer_label.place(x=0, y=0)
        else:
            self.answer_label.config(text="Answer: " + "".join(self.chosen_word))

    def save_score(self):
        scores = []
        
        # Read existing scores, skipping the current player
        if os.path.exists(LEADERBOARD_FILE):
            with open(LEADERBOARD_FILE, "r") as f:
                for line in f:
                    if ":" in line:
                        name, score = line.strip().split(":", 1)
                        if name != self.player_name:
                            scores.append((name, score))
        
        # Add/update the current player's score
        scores.append((self.player_name, str(self.points)))
        
        # Write all scores back
        with open(LEADERBOARD_FILE, "w") as f:
            for name, score in scores:
                f.write(f"{name}:{score}\n")

    def show_leaderboard(self):
        if not os.path.exists(LEADERBOARD_FILE):
            leaderboard = "No scores yet!"
        else:
            with open(LEADERBOARD_FILE, "r") as f:
                scores = [line.strip().split(":") for line in f if ":" in line]
                scores = sorted(scores, key=lambda x: int(x[1]), reverse=True)[:10]
                leaderboard = "\n".join([f"{name}: {score}" for name, score in scores])
        messagebox.showinfo("Leaderboard", leaderboard)

    def make_guess(self):
        guess = self.entry.get().lower()
        self.entry.delete(0, tk.END)
        if not guess:
            self.message.config(text="You are supposed to enter a letter or the full word!")
            return

        # Makes sure to not guess special characters
        if not guess.isalpha():
            self.message.config(text="Only letters are allowed! No numbers or special characters.")
            return

        # Ability to guess the full word
        if guess == "".join(self.chosen_word):
            unrevealed = self.blank_list.count("_")
            self.points += 5 * unrevealed
            self.blank_list = self.chosen_word[:]
            self.label.config(text=" ".join(self.blank_list))
            self.message.config(text="WINNER WINNER CHICKEN DINNER!")
            self.timer_running = False
            
            # Time Bonus
            if self.seconds <= 10:
                self.points += 100
            elif 11 <= self.seconds <= 30:
                self.points += 25
            elif 31 <= self.seconds <= 60:
                self.points += 10
            else:
                self.points += 5
            
            self.points += 10  # +10 for full word
            if self.update_display == 0:
                self.points += 25  # +5 bonus for no incorrect guesses
            self.points_label.config(text=f"Points: {self.points}")
            self.entry.config(state="disabled")
            self.guess_button.config(state="disabled")
            self.save_score()
            return

        # Only allow single letter guesses for the letter bank
        if len(guess) == 1:
            if guess in self.guessed_letters:
                self.message.config(text=f"You already guessed '{guess}' dum dum")
                return
            self.guessed_letters.add(guess)
            self.letter_bank_label.config(
                text="You Have Guessed...: " + " ".join(sorted(self.guessed_letters))
            )

        # Checks the answer to see if it's right or wrong
        correct = False
        for i, letter in enumerate(self.chosen_word):
            if guess == letter:
                if self.blank_list[i] == "_":
                    self.points += 5  # +5 for each new correct letter
                self.blank_list[i] = guess
                correct = True
        
        # Penalty for guessing wrong
        if not correct and len(guess) == 1:
            self.wrong_guesses += 1
            self.points -= 3
            self.message.config(text=f"'{guess}' is not in the word!")

        self.points_label.config(text=f"Points: {self.points}")

        # Checks the answer to see if it's right or wrong
        if not correct and len(guess) == 1:
            if self.update_display < len(HANGMANPICTURES) - 1:
                self.update_display += 1
        self.label.config(text=" ".join(self.blank_list))
        self.hangman_label.config(text=HANGMANPICTURES[self.update_display])
        if self.blank_list == self.chosen_word:
            self.message.config(text="WINNER WINNER CHICKEN DINNER!")
            self.timer_running = False
            self.points += 10  
            if self.update_display == 0:
                self.points += 10  
            self.points_label.config(text=f"Points: {self.points}")
            self.entry.config(state="disabled")
            self.guess_button.config(state="disabled")
            self.save_score()
        elif self.update_display == len(HANGMANPICTURES) - 1:
            self.message.config(text="YOU LOSE :(  The Word Was: " + "".join(self.chosen_word))
            self.timer_running = False  
            self.entry.config(state="disabled")
            self.guess_button.config(state="disabled")
            self.save_score()
    
    # Resets everything (besides points) when you play again
    def reset_game(self):
        self.chosen_word = list(random.choice(word_list))
        self.blank_list = ["_"] * len(self.chosen_word)
        self.update_display = 0
        self.guessed_letters = set()
        self.seconds = 0
        self.timer_running = True
        self.label.config(text=" ".join(self.blank_list))
        self.hangman_label.config(text=HANGMANPICTURES[self.update_display])
        self.letter_bank_label.config(text="Guessed Letters: ")
        self.message.config(text="")
        self.entry.delete(0, tk.END)
        self.points_label.config(text=f"Points: {self.points}")
        self.wrong_guesses = 0
        self.round_points = 0
        self.entry.config(state="normal")         
        self.guess_button.config(state="normal")
    
    # Code for Timer
    def update_timer(self):
        if self.seconds <= 10:
            color = "gold"
        elif 11 <= self.seconds <= 30:
            color = "silver"
        elif 31 <= self.seconds <= 60:
            color = "#cd7f32"  # bronze hex code
        else:
            color = "black"    # default after 60 seconds

        minutes = self.seconds // 60
        seconds = self.seconds % 60
        self.timer_label.config(text=f"Time: {minutes}:{seconds:02d}", fg=color)
        if self.timer_running:
            self.seconds += 1
        self.master.after(1000, self.update_timer)

class BlitzMode:
    def __init__(self, master, return_to_menu_callback):
        self.master = master
        self.return_to_menu_callback = return_to_menu_callback
        self.score = 0
        self.time_left = 180 # 5 minutes in seconds
        self.word_list = word_list[:]
        random.shuffle(self.word_list)
        self.current_word = ""
        self.guessed_letters = set()
        self.blank_list = []
        self.update_display = 0
        self.wrong_guesses = 0

        for widget in self.master.winfo_children():
            widget.destroy()

        self.timer_label = tk.Label(master, text="Time: 05:00", font=("Arial", 16, "bold"))
        self.timer_label.pack(pady=(10, 0))

        self.score_label = tk.Label(master, text="Score: 0", font=("Arial", 12))
        self.score_label.pack()

        self.label = tk.Label(master, text="", font=("Arial", 24))
        self.label.pack(pady=10)

        self.entry = tk.Entry(master)
        self.entry.pack()
        self.entry.bind("<Return>", lambda event: self.make_guess())

        self.guess_button = tk.Button(master, text="Guess", command=self.make_guess)
        self.guess_button.pack(pady=5)

        self.hangman_label = tk.Label(master, text="", font=("Courier", 16), justify="left")
        self.hangman_label.pack()

        self.letter_bank_label = tk.Label(master, text="Guessed Letters: ")
        self.letter_bank_label.pack()

        self.message = tk.Label(master, text="")
        self.message.pack()

        self.next_word()
        self.update_timer()

    def next_word(self):
        self.current_word = list(random.choice(self.word_list))
        self.blank_list = ["_"] * len(self.current_word)
        self.guessed_letters = set()
        self.update_display = 0
        self.wrong_guesses = 0
        self.label.config(text=" ".join(self.blank_list))
        self.hangman_label.config(text=HANGMANPICTURES[self.update_display])
        self.letter_bank_label.config(text="Guessed Letters: ")
        self.message.config(text="")
        self.entry.delete(0, tk.END)
        self.entry.config(state="normal")
        self.guess_button.config(state="normal")

    def update_timer(self):
        minutes = self.time_left // 60
        seconds = self.time_left % 60
        self.timer_label.config(text=f"Time: {minutes:02d}:{seconds:02d}")
        if self.time_left > 0:
            self.time_left -= 1
            self.master.after(1000, self.update_timer)
        else:
            self.end_game()

    def make_guess(self):
        guess = self.entry.get().lower()
        self.entry.delete(0, tk.END)
        if not guess:
            self.message.config(text="You are supposed to enter a letter or the full word!")
            return
        if not guess.isalpha():
            self.message.config(text="Only letters are allowed! No numbers or special characters.")
            return

        # Full word guess
        if guess == "".join(self.current_word):
            self.score += 10 + 5 * self.blank_list.count("_")
            self.score_label.config(text=f"Score: {self.score}")
            self.message.config(text="Correct! Next word...")
            self.entry.config(state="disabled")
            self.guess_button.config(state="disabled")
            self.master.after(1000, self.next_word)
            return

        # Single letter guess
        if len(guess) == 1:
            if guess in self.guessed_letters:
                self.message.config(text=f"You already guessed '{guess}'")
                return
            self.guessed_letters.add(guess)
            self.letter_bank_label.config(
                text="Guessed Letters: " + " ".join(sorted(self.guessed_letters))
            )

        correct = False
        for i, letter in enumerate(self.current_word):
            if guess == letter:
                self.blank_list[i] = guess
                correct = True

        if not correct and len(guess) == 1:
            self.update_display += 1
            self.hangman_label.config(text=HANGMANPICTURES[self.update_display])
            if self.update_display >= len(HANGMANPICTURES) - 1:
                self.message.config(text=f"You lose! The word was: {''.join(self.current_word)}")
                self.entry.config(state="disabled")
                self.guess_button.config(state="disabled")
                self.master.after(1500, self.next_word)
                return

        self.label.config(text=" ".join(self.blank_list))
        self.hangman_label.config(text=HANGMANPICTURES[self.update_display])

        if self.blank_list == self.current_word:
            self.score += 10
            self.score_label.config(text=f"Score: {self.score}")
            self.message.config(text="Correct! Next word...")
            self.entry.config(state="disabled")
            self.guess_button.config(state="disabled")
            self.master.after(1000, self.next_word)

    def end_game(self):
        for widget in self.master.winfo_children():
            widget.destroy()
        end_label = tk.Label(self.master, text="‚è∞ Time's Up! ‚è∞", font=("Arial", 24, "bold"))
        end_label.pack(pady=(40, 10))
        score_label = tk.Label(self.master, text=f"Your Score: {self.score}", font=("Arial", 18))
        score_label.pack(pady=(0, 30))

        play_again_btn = tk.Button(self.master, text="Play Again?", font=("Arial", 14), bg="#4CAF50", fg="white",
                                   command=self.restart)
        play_again_btn.pack(pady=10)

        menu_btn = tk.Button(self.master, text="Return to Menu", font=("Arial", 14), bg="#1976d2", fg="white",
                             command=self.return_to_menu_callback)
        menu_btn.pack(pady=10)

    def restart(self):
        for widget in self.master.winfo_children():
            widget.destroy()
        BlitzMode(self.master, self.return_to_menu_callback)

# Function to run the GUI
if __name__ == "__main__":
    root = tk.Tk()
    def launch_game(mode="main"):
        for widget in root.winfo_children():
            widget.destroy()
        if mode == "blitz":
            BlitzMode(root, lambda: StartScreen(root, launch_game))
        else:
            HangmanGUI(root)
    StartScreen(root, launch_game)
    root.mainloop()
